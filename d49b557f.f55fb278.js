(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{104:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return d})),t.d(n,"default",(function(){return s}));var a=t(2),r=t(6),o=(t(0),t(119)),i={id:"configure_keymap",title:"Configuring keymap.h.cpp",slug:"/configure_keymap"},c={unversionedId:"configure_keymap",id:"configure_keymap",isDocsHomePage:!1,title:"Configuring keymap.h.cpp",description:"Configuring your keyboard - Part 3: Keymap Definition",source:"@site/docs/configuring_firmware_3.md",slug:"/configure_keymap",permalink:"/docs/configure_keymap",editUrl:"https://github.com/jpconstantineau/BlueMicro_BLE/tree/documentation-docusaurus/documentation/docs/configuring_firmware_3.md",version:"current",sidebar:"someSidebar",previous:{title:"Configuring keyboard_config.h",permalink:"/docs/configure_keyboard"},next:{title:"Configuring Advanced Features",permalink:"/docs/configure_combos"}},d=[{value:"Configuring your keyboard - Part 3: Keymap Definition",id:"configuring-your-keyboard---part-3-keymap-definition",children:[{value:"The default layer",id:"the-default-layer",children:[]},{value:"Further layers",id:"further-layers",children:[]},{value:"Rotary Encoder Definition (1 encoder)",id:"rotary-encoder-definition-1-encoder",children:[]},{value:"Rotary Encoder Definition (Up to 8 encoders)",id:"rotary-encoder-definition-up-to-8-encoders",children:[]},{value:"OLED Definition",id:"oled-definition",children:[]},{value:"Speaker/Buzzer/Audio Definition",id:"speakerbuzzeraudio-definition",children:[]}]}],l={rightToc:d};function s(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"configuring-your-keyboard---part-3-keymap-definition"},"Configuring your keyboard - Part 3: Keymap Definition"),Object(o.b)("h3",{id:"the-default-layer"},"The default layer"),Object(o.b)("p",null,'The default layer is the layer which you will most often use. Generally this is the "QWERTY" Layer.\nFor example for the gherkin 3x10:'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"std::array<std::array<Key, MATRIX_COLS>, MATRIX_ROWS> matrix =\n    KEYMAP2ARRAY(KEYMAP(\n        KC_Q,    KC_W,    KC_E,    KC_R,    KC_T,    KC_Y,    KC_U,    KC_I,    KC_O,    KC_P,\n        KC_A,    KC_S,    KC_D,    KC_F,    KC_G,    KC_H,    KC_J,    KC_K,    KC_L,    KC_ESC,\n        KC_Z,    KC_X,    KC_C,    KC_V,    KC_SPC,  KC_BKSPC,KC_B,    KC_N,    KC_M,    KC_NO \n        ));\n        \n")),Object(o.b)("p",null,"Notice the 2 macros being used: ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP2ARRAY")," and ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP"),". Since the ",Object(o.b)("inlineCode",{parentName:"p"},"matrix")," variable is a c++ array, we need to convert the output of the ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP")," macro from a C array to a c ++ array. "),Object(o.b)("h3",{id:"further-layers"},"Further layers"),Object(o.b)("p",null,"For additional layers, you will need to programatically add the layers and the keycodes.  This is done in the function ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"void setupKeymap() {\n\n    uint32_t layer1[MATRIX_ROWS][MATRIX_COLS] =\n        KEYMAP(\n    KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,     KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,\n    KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,     KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,\n    KC_Z,     KC_X,     KC_C,     KC_V,     KC_SPC,    KC_BSPC,  KC_B,     KC_N,     KC_M,     KC_ENT );\n\n    ADDLAYER(_L1, Method::PRESS , layer1);\n\n}\n\n")),Object(o.b)("p",null,"Notice that in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function, we use c arrays that only need the ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP2ARRAY")," macro to help you with your keymap."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ADDLAYER")," macro simplifies the process of adding your layer and has the following arguments:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"LAYER NUMBER"),": The first argument is the layer number.  Unlike the layer keycode, this is a simple number from 0 to 6 (up to 15 may be supported; depending on memory availability and matrix size)."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"ACTIVATION METHOD"),": Generally, you will use the ",Object(o.b)("inlineCode",{parentName:"li"},"Method::PRESS")," method. Other methods are ",Object(o.b)("inlineCode",{parentName:"li"},"Method::MT_TAP"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Method::MT_HOLD"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Method::DT_TAP")," and ",Object(o.b)("inlineCode",{parentName:"li"},"Method::DT_DOUBLETAP"),'. If a key keys triggered using multiple methods, all methods will "fire" and send a keycode.  As such, it\'s useful to use the ',Object(o.b)("inlineCode",{parentName:"li"},"KC_NO")," keycode to avoid sending anything for a specific activation."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"KEYMAP ARRAY"),": This is the C array to load.")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ADDLAYER")," macro wraps the Key::addActivation with a loop for all rows and columns of the key matrix. "),Object(o.b)("p",null,"Note that when using ",Object(o.b)("inlineCode",{parentName:"p"},"KC_NO")," as the keycode within a layer, the firmware will automatically bypass this keycode for this specific key and it won't be added to its mapping.  As such, having lots of ",Object(o.b)("inlineCode",{parentName:"p"},"KC_NO")," keycodes in a layer won't affect the performance of the keyboard."),Object(o.b)("h3",{id:"rotary-encoder-definition-1-encoder"},"Rotary Encoder Definition (1 encoder)"),Object(o.b)("p",null,"You can refer to the configuration of the solfle keyboard - default configuration for a working example for a single encoder."),Object(o.b)("p",null," This configuration uses the hardware QDEC peripheral (Quadrature Decoder) that's part of the nRF52 SoC and uses callbacks to handle rotation."),Object(o.b)("p",null,"You will need to add a few things to your keymap.h file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'#include "KeyScanner.h"  // include at the top with the other includes\nextern DynamicState keyboardstate;\nvoid encoder_callback(int step); // add right after void setupKeymap();\n\n')),Object(o.b)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following 3 lines in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"// Code below makes sure that the encoder gets configured.\n\n  RotaryEncoder.begin(ENCODER_PAD_A, ENCODER_PAD_B);    // Initialize Encoder\n  RotaryEncoder.setCallback(encoder_callback);    // Set callback\n  RotaryEncoder.start();    // Start encoder\n\n")),Object(o.b)("p",null,"You will need to add the  ",Object(o.b)("inlineCode",{parentName:"p"},"encoder_callback()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"void encoder_callback(int step)\n{\n  uint8_t layer = keyboardstate.layer;\n  if ( step > 0 )\n  {\n      switch(layer)\n      {\n          case _L0: KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_UP); break;\n          case _L1: KeyScanner::add_to_encoderKeys(KC_RIGHT); break;\n          case _L2: KeyScanner::add_to_encoderKeys(LSFT(KC_RIGHT)); break;\n          default: ;\n      }\n  }else\n  {\n      switch(layer)\n      {\n          case _L0: KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_DOWN); break;\n          case _L1: KeyScanner::add_to_encoderKeys(KC_LEFT);break;\n          case _L2: KeyScanner::add_to_encoderKeys(LSFT(KC_LEFT));break;\n          default: ;\n      }\n  }  \n}\n\n")),Object(o.b)("p",null,"If you rotate in one direction and the keycodes are for the other direction, simply change the ",Object(o.b)("inlineCode",{parentName:"p"},"if ( step > 0 )")," statement to ",Object(o.b)("inlineCode",{parentName:"p"},"if ( step < 0 )")," or swap the keycodes around."),Object(o.b)("p",null,"You can change the rotary encoder callback to a different function by calling a macro.  This will enable changing the behavior of the rotary encoder at runtime."),Object(o.b)("h3",{id:"rotary-encoder-definition-up-to-8-encoders"},"Rotary Encoder Definition (Up to 8 encoders)"),Object(o.b)("p",null,"You can refer to the configuration of the miniMACRO5 keyboard - default configuration for a working example for 5 encoders."),Object(o.b)("p",null," This configuration uses the software interrupts and uses callbacks to handle rotation.  This limit on the number of encoders supported using software interrupts can be modified in the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jpconstantineau/Adafruit_nRF52_Arduino/blob/master/libraries/RotaryEncoder/SwRotaryEncoder.cpp"}),"library"),".  The Community BSP has a limit of 8 encoders while the adafruit BSP is set to a maximum of 4."),Object(o.b)("p",null,"You will need to add a few things to your keymap.h file.  The example below is from the miniMACRO5 which supports up to 5 encoders."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'#include "KeyScanner.h"  // include at the top with the other includes\nextern DynamicState keyboardstate;\nvoid encoder_callback1(int step);\nvoid encoder_callback2(int step);\nvoid encoder_callback3(int step);\nvoid encoder_callback4(int step);\nvoid encoder_callback5(int step);\n\n')),Object(o.b)("p",null,"You need to instantiate the software encoders in your keymap.cpp.  Add the following before your ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"SwRotaryEncoder RotaryEncoder1,RotaryEncoder2, RotaryEncoder3, RotaryEncoder4, RotaryEncoder5;\n\n")),Object(o.b)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following lines in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"byte encoder_pins_a[] ENCODER_PAD_A;\nbyte encoder_pins_b[] ENCODER_PAD_B;\n// Code below makes sure that the encoder gets configured.\n\n  RotaryEncoder1.begin(encoder_pins_a[0], encoder_pins_b[0]);    // Initialize Encoder\n  RotaryEncoder1.setCallback(encoder_callback1);    // Set callback\n\n  RotaryEncoder2.begin(encoder_pins_a[1], encoder_pins_b[1]);    // Initialize Encoder\n  RotaryEncoder2.setCallback(encoder_callback2);    // Set callback\n\n  RotaryEncoder3.begin(encoder_pins_a[2], encoder_pins_b[2]);    // Initialize Encoder\n  RotaryEncoder3.setCallback(encoder_callback3);    // Set callback\n\n  RotaryEncoder4.begin(encoder_pins_a[3], encoder_pins_b[3]);    // Initialize Encoder\n  RotaryEncoder4.setCallback(encoder_callback4);    // Set callback\n\n#ifdef ARDUINO_NRF52_COMMUNITY  // if you want to initialize more than 4, you need to compile on the Community BSP\n    RotaryEncoder5.begin(encoder_pins_a[4], encoder_pins_b[4]);    // Initialize Encoder\n  RotaryEncoder5.setCallback(encoder_callback5);    // Set callback\n#endif\n\n")),Object(o.b)("p",null,"You will need to add the  ",Object(o.b)("inlineCode",{parentName:"p"},"encoder_callback()")," functions (one per encoder):"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"\nvoid encoder_callback1(int step)\n{\n  keyboardstate.encoder1pos = keyboardstate.encoder1pos + step; \n\n  if (abs(keyboardstate.encoder1pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder1pos < 0  )\n    {\n      KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_UP); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_DOWN); \n    } \n    keyboardstate.encoder1pos = 0; \n  } \n}\n\nvoid encoder_callback2(int step)\n{\n  keyboardstate.encoder2pos = keyboardstate.encoder2pos + step; \n\n  if (abs(keyboardstate.encoder2pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder2pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_RIGHT); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_LEFT);\n    } \n    keyboardstate.encoder2pos = 0; \n  } \n}\n\nvoid encoder_callback3(int step)\n{\n  keyboardstate.encoder3pos = keyboardstate.encoder3pos + step; \n\n  if (abs(keyboardstate.encoder3pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder3pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_L); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_J);\n    } \n    keyboardstate.encoder3pos = 0; \n  } \n}\n\nvoid encoder_callback4(int step)\n{\n  keyboardstate.encoder4pos = keyboardstate.encoder4pos + step; \n\n  if (abs(keyboardstate.encoder4pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder4pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_COMMA); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_DOT);\n    } \n    keyboardstate.encoder4pos = 0; \n  } \n}\n\nvoid encoder_callback5(int step)\n{\n  keyboardstate.encoder5pos = keyboardstate.encoder5pos + step; \n\n  if (abs(keyboardstate.encoder5pos) > ENCODER_RESOLUTION)\n  {\n    if ( keyboardstate.encoder5pos < 0  )\n    {\n  \n      KeyScanner::add_to_encoderKeys(KC_UP); \n    }\n    else \n    {\n      KeyScanner::add_to_encoderKeys(KC_DOWN);\n    } \n    keyboardstate.encoder5pos = 0; \n  } \n}\n\n")),Object(o.b)("p",null,"If you rotate in one direction and the keycodes are for the other direction, simply change the ",Object(o.b)("inlineCode",{parentName:"p"},"if ( step > 0 )")," statement to ",Object(o.b)("inlineCode",{parentName:"p"},"if ( step < 0 )")," or swap the keycodes around."),Object(o.b)("p",null,"You can change the rotary encoder callback to a different function by calling a macro.  This will enable changing the behavior of the rotary encoder at runtime."),Object(o.b)("h3",{id:"oled-definition"},"OLED Definition"),Object(o.b)("p",null,"The default screens can be overriden by assigning a new callback."),Object(o.b)("p",null,"You will need to add a few things to your keymap.h file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'#include "BlueMicro_display.h"\n\n#ifdef BLUEMICRO_CONFIGURED_DISPLAY\nextern BlueMicro_Display OLED;        // needed to assign the update display callback\nextern DISPLAY_U8G2_CONSTRUCTOR u8g2; // needed to call the display functions\n#endif\n\nvoid updateDisplay(PersistentState* cfg, DynamicState* stat);\n\n')),Object(o.b)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following 3 lines in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"\n    #ifdef BLUEMICRO_CONFIGURED_DISPLAY\n    OLED.setStatusDisplayCallback(updateDisplay);\n    #endif\n\n")),Object(o.b)("p",null,"You will then need to define the ",Object(o.b)("inlineCode",{parentName:"p"},"updateDisplay()")," function with your own requirements.  The following is an example that provides a battery icon, the computer or half it is connected to and the currently active layer. "),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'void updateDisplay(PersistentState* cfg, DynamicState* stat)\n{\n    #ifdef BLUEMICRO_CONFIGURED_DISPLAY\n    u8g2.setFontMode(1);    // Transparent\n    u8g2.setFontDirection(0);\n    battery(22,19,stat->vbat_per);\n    printline(0,28,stat->peer_name_prph);\n\n    char buffer [50];\n    u8g2.setFont(u8g2_font_helvB12_tf); // choose a suitable font\n    switch(stat->layer)\n    {\n        case _QWERTY:     u8g2.drawStr(0,128,""); break;\n        case _LOWER:      u8g2.drawStr(0,128,"L");break;\n        case _RAISE:     u8g2.drawStr(0,128,"R");break;\n        case _ADJUST:     u8g2.drawStr(0,128,"A");break;\n        case _EXTRAL:     u8g2.drawStr(0,128,"EL");break;\n        case _EXTRAR:     u8g2.drawStr(0,128,"ER");break; \n        case _MACROL:     u8g2.drawStr(0,128,"ML");break;\n        case _MACROR:     u8g2.drawStr(0,128,"MR");break; \n        case _MACRO:     u8g2.drawStr(0,128,"M");break;    \n    }\n    #endif\n}\n')),Object(o.b)("h3",{id:"speakerbuzzeraudio-definition"},"Speaker/Buzzer/Audio Definition"),Object(o.b)("p",null,"If you want to add additional audio feedback to your macros or user functions, you will need to add a few lines to your keymap.h file:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'#include "BlueMicro_tone.h"\nextern BlueMicro_tone speaker; \n')),Object(o.b)("p",null,"Refer to the Luddite, default keymap for an example how to add music to your macros."))}s.isMDXComponent=!0},119:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return y}));var a=t(0),r=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),s=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},b=function(e){var n=s(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),b=s(t),u=a,y=b["".concat(i,".").concat(u)]||b[u]||p[u]||o;return t?r.a.createElement(y,c(c({ref:n},l),{},{components:t})):r.a.createElement(y,c({ref:n},l))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var c={};for(var d in n)hasOwnProperty.call(n,d)&&(c[d]=n[d]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var l=2;l<o;l++)i[l]=t[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);